<div>

        <p><a href="http://labs.twistedmatrix.com/2008/07/twisted-in-news.html">Seems</a> like <a href="http://syllogism.co.za/2008/07/thoughts-on-frameworks-why-i-u.html">everyone</a> is <a href="http://labs.twistedmatrix.com/2008/07/twisted-in-news.html">suddenly</a> <a href="http://oubiwann.blogspot.com/2008/07/divmod-tech-making-next-gen-grade.html">talking</a> about <a href="http://twistedmatrix.com/">Twisted</a> / <a href="http://divmod.org/">Divmod</a> / etc, so I thought I&#39;d throw in some commentary on why I use <a href="http://divmod.org/trac/wiki/DivmodMantissa">Mantissa</a>. I&#39;ll start at the bottom of the stack, with Twisted. (If I start discussing &quot;why *Python*?&quot; I&#39;ll probably never finish this post!) The core of Twisted is an asynchronous network / I/O framework; around this core is a variety of code built on top of this framework: Twisted includes implementations of many network protocols, and has a number of useful abstractions that form part of those implementations.</p><p>One of the key principles that people in the Twisted community seem to generally subscribe to, is that the primary goal of a piece of code is to do the &quot;right&quot; thing. Of course, despite the best efforts of the great coding wizards, mistakes are still made, and manpower is always short, so the result is not always a perfect glistening gem of coding perfection; but the focus is still on &quot;do it right&quot;. There is a mantra (attributed to a variety of people) that goes &quot;Make it work, make it right, make it fast&quot;; in my opinion, when that ordering is violated, the results are typically a disaster. Any codebase that achieves widespread use must at least get the &quot;make it work&quot; part done first, but often the next step is &quot;make it fast&quot;; not necessarily in the sense of the performance of the codebase, but also in terms of development effort. The result is an environment and culture that optimizes for getting the wrong thing done quickly, and in the process, typically making it harder or impossible to get the right thing done.</p><p>In many contexts, this isn&#39;t such a big deal; it&#39;s okay to get a result that is only &quot;50%&quot; or even &quot;25%&quot; in many cases, either just ignoring the breakage, or dealing with it piecemeal as you go along. Unfortunately (or fortunately, perhaps), I&#39;m an idealist at heart. I retain enough pragmatism to operate in the real, flawed, world, but idealistic compromise is mentally unpleasant to me, so I avoid it as much as possible. There are mostly only two contexts I write code in: the personal context, where I&#39;m doing it mostly for enjoyment, and thus have the freedom to be as idealistic as I want; and then the business context, where I&#39;m being paid to make things work in the long-term, and need to produce high-quality results. So, either way, I&#39;m looking to spend more time writing code that does the right thing (which ultimately saves me time in the long run), rather than worrying about getting any old junk working as quickly as possible, and this aligns perfectly with the attitude of the Twisted community, at least as I perceive it. Thus, while others complain with the learning curve involved with this stack, I have no problems spending the time needed to become familiar with everything I need to unlock the true power of the stack. In most cases, I find that I&#39;m not &quot;struggling&quot; to learn the technology, it&#39;s just that it does so much more for me, that I need to spend more time finding out about how to use it, and ultimately saving myself far more time in the long run. The time spent learning is not time lost, but time invested.</p><p>So, Twisted provides asynchronous networking and protocol implementations, such as a web server; the layers of the stack above Twisted start to tie me down more in terms of architectural approach, but this is still an acceptable cost for me (although I wouldn&#39;t necessarily choose this set of technologies for every single project I write). <a href="http://divmod.org/trac/wiki/DivmodAxiom">Axiom</a> provides synchronous in-process database access, and more importantly, schema management. This frees me from the task of managing a separate database server process, while simultaneously providing a mapping from the database schema to data objects, and a framework (&quot;upgraders&quot;) for managing changes in that schema (as opposed to the usual ad-hoc scripting approach that seems to be the norm).</p><p><a href="http://divmod.org/trac/wiki/DivmodNevow">Nevow</a>... well, there are a lot of things wrong with Nevow; it contains large swathes of outdated code that should generally just be avoided, and some of the internals (&quot;context&quot;, anyone?) are really awful, and need to be replaced. In addition, it ends up replacing half of twisted.web&#39;s webserver implementation; while this replacement is mostly for the better, that code really belongs back in twisted.web, instead of having the web server code schizophrenically split between the two codebases. Yet, despite all of that, Nevow still does a pretty good job of letting me do &quot;the right thing&quot;, even if Nevow itself isn&#39;t always doing the right thing; the bad parts of Nevow are an eyesore, but it&#39;s not that hard to just ignore them, and use the good parts. The templating system has a heart of gold, allowing me to cleanly separate my templating markup, my rendering logic, and my data model. Add Athena to the mix, and I now have bi-directional communication between browser and server (COMET, if you like), and a JavaScript modules system that continues the theme of code separation, keeping my JavaScript separate from the rest; I also get a JavaScript class-based object model.</p><p>Mantissa sits atop the other elements of the stack, as the application server. It provides abstractions along application lines, allowing different applications (in the form of &quot;offerings&quot;) to co-exist in the same Mantissa server, and along user lines, storing each user&#39;s data in their own Axiom store (database, and this is actually mostly an Axiom feature, although it has been argued that the code should be moved into Mantissa), and providing a &quot;sharing&quot; system to control access to the data in the users&#39; stores. For the most part, Mantissa&#39;s functionality is currently web-based; but this is simply a matter of where the effort has been focused so far, and not a reflection of the underlying design -- Mantissa&#39;s design is multi-protocol, allowing for an HTTP server sitting alongside anything else you might want (SMTP, IMAP, XMPP, SIP, whatever). This brings me to another important property that is pervasive within this stack; while Mantissa (and dependencies) may not have the popularity and thus the manpower that other projects enjoy, the components are typically designed in a fashion amenable to extension. If I need some functionality that nobody has had time to work on yet, I&#39;ll obviously have to write a fair amount of code to get the job done; but I typically won&#39;t have to overpower Mantissa in a brutal battle of wills just to get it to let me start working on what I want done. I simply provide the code for the parts that haven&#39;t been implemented yet, plugging them into the parts that *have* been implemented. This way I reap the benefits of the work that has been done by others without running into any nasty surprises later on once the need to go beyond that work arises; something that is essentially guaranteed to happen when working on any significantly large project.</p><p>In summary, I use Mantissa in a lot of my projects because it provides a lot of useful functionality that aids me in my quest to write good software, while at the same time getting out of my way when it comes time to go beyond the bounds of what it provides me with. Invariably, this choice means that certain architectural decisions have been made for me, decisions that can&#39;t easily be changed or reversed by building on top of the stack; for some projects, those decisions are inappropriate, and thus I&#39;ll c

hoose differently; but those decisions have usually been made by some pretty smart people, and are generally sound ones in the contexts in which they are appropriate.</p><p>Hopefully I&#39;ve managed to convey the high-level attraction I have to Mantissa and related software; please note that I&#39;m not trying to justify the low-level decisions involved here. Want to argue about how PostgreSQL is a superior database solution than SQLite? Why per-user database are a bad idea? How &quot;COMET&quot; and web applications that require JS are ruining the web? Sure, I&#39;d be glad to have those discussions, but the point of this post was not to defend the specifics; think of it more as a window onto the development world I immerse myself in most of the time; and hopefully a little of my enthusiasm has been passed on to you!<br /></p>

                </div>